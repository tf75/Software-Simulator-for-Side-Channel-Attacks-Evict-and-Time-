#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef unsigned char byte; /*This is used to represent the state as a byte array */
typedef unsigned int word;

/* The number of columns comprising a state in AES. This is a constant in AES. Value=4 */
#define Nb 4
/* The number of 32 bit words in a key. */
#define Nk 4

/*A union is like a structure in which all members are stored at the same address. The block is to be used for the state */
typedef union
{ byte b[16];
  byte bm[4][4];
  word w[4];
} BLOCK;

BLOCK aesin,aesout; /*pointers to the block - aesin and aesout are input/output of the function aesprocess, seen as byte arrays rather than int */
BLOCK temp0,temp1;

int Nr,Nr4minus1;

int ekeywdim,ekeywdimminus1,roundpairs;

/* ukey is the user-given key, ekey is the expanded key. */

typedef union
{ byte b[32];
  byte bm[8][4];
  word w[8];
} USERKEY;

USERKEY ukey;

typedef union
{ byte b[256];
  byte bm[64][4];
  word w[64];
} EXPANDEDKEY;

EXPANDEDKEY ekey;

struct strtable {
    byte** str;
};
typedef struct strtable Strtable;

/*Plaintext values used to create random 16 byte plaintext array */
byte num1[256]={
/* 0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F */
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };


/* S-box FIPS-197 */

byte sbox[256]={
/* 0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F */
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

/*This is used for the inverse, yet not used in this run */
byte invsbox[256];

/*This struct is used in the t-table look up */
typedef union
{ byte b[1024];
  byte bm[256][4];
  word w[256];
} TABLE;

/* The tables t's and v's are for encryption and decryption
 respectively. (See the book of Daemen and Rijmen, pp.56-59,
 for detailed explanation of the tables t's.)
 The tables u's and w's are
 similar to the tables t's and v's but use an identity
 matrix. The table y is the identity of the byte extended
 with three zero bytes. */

/*These are the T-tables */
TABLE t0,t1,t2,t3,u0,u1,u2,u3,y;

/* The round constant word array, Rcon[i], contains the values given by
 x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
 Note that i starts at 1, not 0).*/

const byte RC[255] = {
  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
  0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
  0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
  0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
  0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
  0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
  0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
  0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
  0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
  0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
  0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
  0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
  0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
  0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
  0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
  0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };

  void aesdemo();
  byte plaintext_bytes();
  void display(byte b[], int size);
  void aeskeyschedule();
  void aesprocess();
  byte gfmult(byte a, byte b);
  void computetables();
  byte switch_AES(int num, int col);
  byte plaintext_bytes();
  void printplaintext(byte pt[]);
  void aesdemo();


  int main(){
   srand(time(NULL)); /*So random number generation is random and does not produce the same value */
   aesdemo();
   return 0;
 }

/*TO display the plaintext and AES key output */
void display(byte b[], int size){
  int i;
  for (i=0; i < size; i++){
  	printf(" %2.2x",b[i]); if ((i%16)==15) printf("\n");
  }
  if ((size%16)!=0) printf("\n"); printf("\n");
}

/*To produce the 176 bits of the key needed for encryption,
a good reference please find here:  http://www.samiam.org/key-schedule.html */
void aeskeyschedule(){
  int i,ii;
  word *wp;
  byte *bp;

  for (i=0; i < Nk; i++) {
  ekey.w[i]=ukey.w[i];
  }
  ii=0;
  wp=&ekey.w[Nk];
  bp=(byte *) & ekey.w[Nk-1];
  if (Nk==4){
   for (i=0; i < 10; i++){
    wp[0]=wp[-4]^y.w[RC[++ii]]^u0.w[bp[1]]^u1.w[bp[2]]^u2.w[bp[3]]^u3.w[bp[0]];
    wp[1]=wp[-3]^wp[0];
    wp[2]=wp[-2]^wp[1];
    wp[3]=wp[-1]^wp[2];
    wp+=4; bp+=16;
   }
  }
  else{
       fprintf(stderr, "Nk has been set incorrectly. Program is exiting please look at source code \n");
       exit(-1);
  }

}

/*This is the actual encryption where the plaintext bytes are encrypted */
 void aesprocess()
{
  int x;
  word *wp;

  /*This encrypts and does not include the decrypt table lookups */
    wp=&ekey.w[0];
    temp0.w[0]=(*wp++)^aesin.w[0];
    temp0.w[1]=(*wp++)^aesin.w[1];
    temp0.w[2]=(*wp++)^aesin.w[2];
    temp0.w[3]=(*wp++)^aesin.w[3];
    for (x=1; x < roundpairs; x++)
    {
      temp1.w[0]=(*wp++)^
      /*printf( "&T = %p\n", &t0.w ); - used to see access of T-table */
                 t0.w[temp0.bm[0][0]]^t1.w[temp0.bm[1][1]]^
                 t2.w[temp0.bm[2][2]]^t3.w[temp0.bm[3][3]];
      temp1.w[1]=(*wp++)^
                 t0.w[temp0.bm[1][0]]^t1.w[temp0.bm[2][1]]^
                 t2.w[temp0.bm[3][2]]^t3.w[temp0.bm[0][3]];
      temp1.w[2]=(*wp++)^
                 t0.w[temp0.bm[2][0]]^t1.w[temp0.bm[3][1]]^
                 t2.w[temp0.bm[0][2]]^t3.w[temp0.bm[1][3]];
      temp1.w[3]=(*wp++)^
                 t0.w[temp0.bm[3][0]]^t1.w[temp0.bm[0][1]]^
                 t2.w[temp0.bm[1][2]]^t3.w[temp0.bm[2][3]];

      temp0.w[0]=(*wp++)^
                 t0.w[temp1.bm[0][0]]^t1.w[temp1.bm[1][1]]^
                 t2.w[temp1.bm[2][2]]^t3.w[temp1.bm[3][3]];
      temp0.w[1]=(*wp++)^
                 t0.w[temp1.bm[1][0]]^t1.w[temp1.bm[2][1]]^
                 t2.w[temp1.bm[3][2]]^t3.w[temp1.bm[0][3]];
      temp0.w[2]=(*wp++)^
                 t0.w[temp1.bm[2][0]]^t1.w[temp1.bm[3][1]]^
                 t2.w[temp1.bm[0][2]]^t3.w[temp1.bm[1][3]];
      temp0.w[3]=(*wp++)^
                 t0.w[temp1.bm[3][0]]^t1.w[temp1.bm[0][1]]^
                 t2.w[temp1.bm[1][2]]^t3.w[temp1.bm[2][3]];
    }


      /*Last table for the lookup round that omits mix columns */

    temp1.w[0]=(*wp++)^
               t0.w[temp0.bm[0][0]]^t1.w[temp0.bm[1][1]]^
               t2.w[temp0.bm[2][2]]^t3.w[temp0.bm[3][3]];
    temp1.w[1]=(*wp++)^
               t0.w[temp0.bm[1][0]]^t1.w[temp0.bm[2][1]]^
               t2.w[temp0.bm[3][2]]^t3.w[temp0.bm[0][3]];
    temp1.w[2]=(*wp++)^
               t0.w[temp0.bm[2][0]]^t1.w[temp0.bm[3][1]]^
               t2.w[temp0.bm[0][2]]^t3.w[temp0.bm[1][3]];
    temp1.w[3]=(*wp++)^
               t0.w[temp0.bm[3][0]]^t1.w[temp0.bm[0][1]]^
               t2.w[temp0.bm[1][2]]^t3.w[temp0.bm[2][3]];

    aesout.w[0]=(*wp++)^
                u0.w[temp1.bm[0][0]]^u1.w[temp1.bm[1][1]]^
                u2.w[temp1.bm[2][2]]^u3.w[temp1.bm[3][3]];
    aesout.w[1]=(*wp++)^
                u0.w[temp1.bm[1][0]]^u1.w[temp1.bm[2][1]]^
                u2.w[temp1.bm[3][2]]^u3.w[temp1.bm[0][3]];
    aesout.w[2]=(*wp++)^
                u0.w[temp1.bm[2][0]]^u1.w[temp1.bm[3][1]]^
                u2.w[temp1.bm[0][2]]^u3.w[temp1.bm[1][3]];
    aesout.w[3]=(*wp++)^
                u0.w[temp1.bm[3][0]]^u1.w[temp1.bm[0][1]]^
                u2.w[temp1.bm[1][2]]^u3.w[temp1.bm[2][3]];
  }

/*Galois Field multiplication */
byte gfmult(byte a, byte b)
{ byte r,t;
  if (a < b) { t=b; b=a; a=t; }
  r=0;
  do
  { if (b&0x01) r^=a;
    if (a&0x80) a=(a<<1)^0x1b; else a<<=1;
  } while (b>>=1);
  return r;
}

/*This sets up the tables for the encryption and decryption to be actived at the beginning before encryption starts*/
void computetables()
{
  int i,j;
  byte s;
  for (i=0; i<256; i++) invsbox[sbox[i]]=i;
  for (i=0; i<256; i++)
  { s=sbox[i];
    t0.bm[i][0]=gfmult(s,0x02); t0.bm[i][1]=t0.bm[i][2]=s;
    t0.bm[i][3]=gfmult(s,0x03);
    u0.bm[i][0]=s; u0.bm[i][1]=u0.bm[i][2]=u0.bm[i][3]=0;
    y.bm[i][0]=i; y.bm[i][1]=y.bm[i][2]=y.bm[i][3]=0;
    for (j=0; j<4; j++)
    { t1.bm[i][j]=t0.bm[i][(j+3)%4];
      t2.bm[i][j]=t0.bm[i][(j+2)%4];
      t3.bm[i][j]=t0.bm[i][(j+1)%4];
      u1.bm[i][j]=u0.bm[i][(j+3)%4];
      u2.bm[i][j]=u0.bm[i][(j+2)%4];
      u3.bm[i][j]=u0.bm[i][(j+1)%4];
    }
  }
}


byte plaintext_bytes(){
	/*this assigns random bytes to the plaintext message*/
    int randbyte;
    byte value;
    randbyte = rand()%(255-0) + 0; /*get rand byte from table */
    if(randbyte < 256 && randbyte >= 0){
    value = num1[randbyte];
    }
    else{
    printf("There has been error in assigning value to plaintext this is the number produced %d \n", randbyte);
    exit(-1);
    }
    return value;
}



void aesdemo()
{
  int i;
  byte pt[16];
  /*http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf - -Where the AES key is sourced from */


  byte key[16] = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,
                   0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c };

  Nr = 10;
  Nr4minus1=Nr*4-1;
  ekeywdim=Nb*(Nr+1);
  ekeywdimminus1=ekeywdim-1;
  roundpairs= Nr/2;

  /*The key is constant and not changed unless done by the user in the source code*/

  for (i=0; i<16; i++)
  {
   ukey.b[i]=key[i];
  }
  computetables();
  aeskeyschedule();

  	/*To gather the 16 bytes of rand plaintext bytes */
   for(i = 0; i < 16; i++){
     pt[i] = plaintext_bytes();
   }

    if(sizeof(pt) != 16){
      fprintf(stderr, "There has been an error in assigning values to plaintext 16 byte, the size is not of 16 bytes \n");
      exit(-1);
    }

  for (i=0; i<16; i++){
   aesin.b[i]=pt[i];
  }

  printf("plaintext being encrypted :\n");
  display(aesin.b,16);

  printplaintext(aesin.b);

  aesprocess();


  printf("ciphertext:\n");
  display(aesout.b,16);

  printf("\naesdemo run ended\n");

}

/*This prints in order the plaintext bytes inputted by the random function */
void printplaintext(byte pt[])
{
    int i;
    FILE *file = fopen("/home/tf75/Documents/Master's project/Set Cache/plaintext/plaintext.txt", "a");
    if (file == NULL)
    {
        fprintf(stderr, "Error opening file!\n");
        exit(EXIT_FAILURE);
    }
   for (i = 0; i < 16; i++)
   {
    fprintf(file, "%2.2x", pt[i]);
    fprintf(file, " ");
    }
    fprintf(file, "\n");
   fclose(file);
}
